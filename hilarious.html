<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Hilarious Editor</title>
  <style>
/* CSS reset */
html,body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,select,p,blockquote,th,td{margin:0;padding:0}
h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:inherit;}
img{color:transparent;font-size:0;border:0;vertical-align:middle;}

html,body {
  height: 100%;
  width: 100%;
  color: #006;
  background-color: #fec;
  font-family: "Courier New", Courier, monospace;
  font-size: 10px;
  line-height: 1;
  white-space: nowrap;
}

#bar, #linenos, #editor {
  display: inline-block;
  vertical-align: top;
  white-space: normal;
}
#bar {
  min-height: 100%;
  width: 20em;
  background-color: #cfe;
}
#bar > div {
  margin-top: 1em;
  margin-bottom: 1em;
}
#linenos {
  background-color: #fce;
  text-align: right;
  padding: 0 1px;
  white-space: pre;
}
#linenos > a {
  display: block;
  text-decoration: none;
  color: #00f;
}
#linenos > a:visited {
  color: #00f;
}
#editor {
  margin-bottom: 1em;
}
#editor, #testline {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  resize: none;
  overflow: hidden;
  border-width: 0px;
  white-space: pre-wrap;
  width: 80ch;
  /*
    word-break is maybe not the most aesthetic, but it makes it easy to 
    compute where the line numbers go, and easy for the users to see
    how much whitespace they have, so we'll go with it for now
  */
  word-break: break-all;
}
#testline {
  visibility: hidden;
  position: absolute;
  left: -1000px;
  height: 1px;
}
#ask-for-token {
  position: fixed;
  width: 100%;
  height: 100%;
  top: 0; left: 0; bottom: 0; right: 0;
  background: rgba(200, 200, 200, 0.85);
  text-align: center;
  display: table;
}
#ask-for-token > label {
  display: table-cell;
  vertical-align: middle;
}
#ask-for-token > label > p {
  font-size: 2em;
}
#token {
  font-size: 1.2em;
  font-family: inherit;
  line-height: inherit;
  width: 21em;
  margin-top: 0.5em;
  height: 2em;
}
#context_name {
  padding: 0.5em;
  font-weight: bold;
  word-wrap: break-word;
  margin-left: 2em;
  text-indent: -2em;
}
#editable_files > a {
  display: block;
  padding: 0.5em; /* expand the click target by using padding */
}
#editable_files > a.current-file {
  font-weight: bold;
}
#notes {
  padding: 2.5em 0.5em 0;
}
  </style>
</head>
<body
  ><div id="ask-for-token" style="display: none;"><label><p>Token:</p><input type="password" id="token" autofocus></label></div
  ><div id="bar"><div id="save-status"></div><div id="context_name"></div><div id="editable_files"></div><div id="notes">Known bugs: You are not protected from editing your stuff twice; The editor doesn't notice if the file disappears and it keeps overwriting it.</div></div
  ><div id="linenos"></div
  ><textarea id="editor" spellcheck="false"></textarea>
  <textarea id="testline"></textarea>
<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script>
(function(){
"use strict";

if(window.console === undefined) {
  window.console = { log: function() {} };
}

var editor = document.getElementById('editor');
var save_status = document.getElementById('save-status');
var $editor_and_testline = $('#editor, #testline');

var state = {
  auth_token: '',

  current_file: null,

  context_name: '',

  // filename: true
  editable_files: {},

  // filename: { selectionStart: _, selectionEnd: _, selectionDirection: _}
  remembered_selections: {}
};

var intended_editor_width = 80;

function cachebuster() {
  return '' + Date.now() + Math.random();
}

function auth_headers() {
  return {
    'X-Please-Believe-I-Am-Not-Cross-Domain': 'yes',
    'X-Token': state.auth_token
  };
}

function test_auth(callback, failure_callback) {
  $.ajax({
    url: '/test_post_works?'+cachebuster(),
    method: 'POST',
    headers: auth_headers(),
    success: callback,
    failure: failure_callback
  });
}


// todo save if somdhc
var trying_to_save = false;
var save_interval = null;
var save_req = null;
var last_sync_attempt;
var last_edit = 0;
var last_sync_success;
var latest_time_that_the_server_has_all_our_data; // in theory updated continously when the server has our data, but actually only retroactively updated once the user types something to be the moment before they typed
function call_intermittently_while_trying_to_save() {
//function call_intermittently_when_active() {
//function call_intermittently() {
  var time_unsaved = Date.now() - latest_time_that_the_server_has_all_our_data;
  if(time_unsaved > 91000) {
    $(save_status).text('Last saved '+Math.round(time_unsaved/1000/60)+' minutes ago');
  }
  debounced_save();
}
function describe_since(time) {
  var duration = Date.now() - time;
  var date = new Date(time);
  var short_since = "since "+date.getHours()+":"+date.getMinutes()+":"+date.getSeconds();
  if(duration < 6000) {
    return "from the last few seconds";
  } else if(duration < 1.6*60*1000) {
    return short_since + " (" + Math.round(duration/1000) + " seconds ago)";
  } else if(duration < 1.6*3600*1000) {
    return short_since + " (" + Math.round(duration/1000/60) + " minutes ago)";
  } else if(duration < 1.6*86400*1000) {
    return "since " + date + " (" + Math.round(duration/1000/3600) + " hours ago)";
  } else {
    return "since " + date + " (" + Math.round(duration/1000/86400) + " days ago)";
  }
}

// this should be active the millisecond after someone starts typing.
// not 2.5 seconds later when the save attempt starts.
// why bother removing and adding it all the time.
function unsaved_beforeunload(e) {
  // In the time the user is looking at the message, maybe we can
  // squeeze in a save.  An example circumstance where this is useful:
  // if they click "don't close the tab" and then try closing the tab again,
  // hopefully the second time they close the tab it will already be saved
  // so we don't have to warn them again.
  try_save();
  // some changes haven't saved yet!
  //var time_unsaved = Date.now() - latest_time_that_the_server_has_all_our_data;
  //var message = "changes from the last " + describe_millisecond_duration(time_unsaved) + " haven't saved yet!"
  var message = "changes " + describe_since(latest_time_that_the_server_has_all_our_data) + " haven't saved yet!";
  e.returnValue = message; // some browsers
  return message; // other browsers
}

function we_will_need_to_save() {
  if(!trying_to_save) {
    trying_to_save = true;
    window.addEventListener('beforeunload', unsaved_beforeunload);
  }
}
function starting_saving() {
  if(!save_interval) {
    save_interval = setInterval(call_intermittently_while_trying_to_save, 60000);
  }
  we_will_need_to_save();
}
function all_done_saving() {
  trying_to_save = false;
  if(save_interval !== null) {
    clearInterval(save_interval);
  }
  window.removeEventListener('beforeunload', unsaved_beforeunload);
  save_req = null;
  $(save_status).empty();
}
// call debounced_save() instead of this
// to make sure we don't try to start saving while the user's
// typing
function try_save() {
  // is 30 seconds enough for saving??
  var req_timeout = 30000;
  if(save_req !== null) {
    if(last_sync_attempt + req_timeout < Date.now()) {
      save_req.abort();
    } else {
      return;
    }
  }
  last_sync_attempt = Date.now();
  starting_saving();
  var f = state.current_file;
  var which_file_header = ((f != null) ? { 'X-File': f } : {});
  save_req = $.ajax({
    url: '/save?'+cachebuster(),
    method: 'POST',
    data: editor.value,
    timeout: req_timeout,
    headers: _.assign({},
      {'Content-Type': 'text/plain; charset=utf-8'},
      which_file_header,
      auth_headers()),
    success: function(data) {
      latest_time_that_the_server_has_all_our_data = last_sync_success = last_sync_attempt;
      save_req = null;
      if(last_sync_success < last_edit) {
        debounced_save();
      } else {
        all_done_saving();
      }
    }
  });
}
var debounced_save = _.debounce(try_save, 2500);

//function editorchange_less_urgent() {
//  last_edit = Date.now();
//  try_save();
//}
//var debounced_editorchange_less_urgent = _.debounce(editorchange_less_urgent, 2500);

function adjust_editor_height() {
  if(editor.scrollHeight > editor.clientHeight) {
    editor.style.height = editor.scrollHeight+'px';
  }
  debounced_compute_line_numbers();
}
function editor_input() {
  adjust_editor_height();
  var now = Date.now();
  if(last_edit <= latest_time_that_the_server_has_all_our_data) {
    if(latest_time_that_the_server_has_all_our_data < now) {
      latest_time_that_the_server_has_all_our_data = now - 1;
    }
  }
  last_edit = now;
  we_will_need_to_save();
  debounced_save();
  //debounced_editorchange_less_urgent();
}

function compute_line_numbers() {
  var s = '';
  var line_height = +$(editor).css('line-height').replace(/px$/, '');
  var $testline = $('#testline');
  _.each(editor.value.split('\n'), function(line, idx) {
    var lineno = idx + 1;
    // This len/80 version didn't work in some weird cases with long lines
    // where the browsers decide to wrap the lines earlier
    // than the 80th character.  The details seem hard to predict
    // and vary from browser to browser.  (Sometimes for example
    // the browser tries to prevent a displayed-line from beginning
    // with a space character, I think based on experimenting.
    // But it wasn't very consistent.)  In theory "word-break: break-all;"
    // should make them not do that, I think... but in practice,
    // that only works *almost* all the time, not all the time.
    //
    // var lines = Math.max(1, Math.ceil(line.length / intended_editor_width));
    var lines = 1;
    if(line.length > intended_editor_width) {
      // This works more often than the len/80 version, although
      // it still misses a few cases -- at least cases that are
      // fixed by fix_reflow_bugs() so it's important that
      // fix_reflow_bugs gets called when loading a new document.
      // (It's probably too slow and probably unnecessary to call it
      // all the time.)
      $testline.text(line);
      lines = Math.round($testline.prop('scrollHeight') / line_height);
      //console.log(lineno, line.length, lines);
    }
    s += lineno;
    while(lines > 0) {
      s += '\n';
      --lines;
    }
  });
  $testline.empty();
  var $linenos = $('#linenos');
  // It's probably faster not to modify the DOM if there's no change.
  // And there's usually no change.
  var old_linenos_text = $linenos.text();
  if(old_linenos_text !== s) {
    $linenos.text(s);
    fix_reflow_bugs();
    // Just in case we missed something in adjust_editor_height(),
    // here's a related computation:
    if($linenos.height() > $(editor).height()) {
      editor.style.height = $linenos.height() + 'px';
    }
  }
}
var debounced_compute_line_numbers = _.debounce(compute_line_numbers, 50);

editor.addEventListener('input', editor_input);

function repeat(str, count) {
  if(str.repeat) {
    return str.repeat(count);
  } else {
    // shorter version of
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
    var rpt = '';
    for (;;) {
      if ((count & 1) == 1) {
        rpt += str;
      }
      count >>>= 1;
      if (count === 0) {
        break;
      }
      str += str;
    }
    return rpt;
  }
}

function fix_ch_unit() {
  var fix_needed = false;
  var font_size_str = $(editor).css('font-size');
  var font_size = +font_size_str.replace(/px$/, '');
  var zeroes = repeat('0', intended_editor_width);
  var $a = $('<div/>').text(zeroes).css({'font-size': font_size_str, 'visibility': 'hidden', 'position': 'absolute', 'top': '0', 'left': '0'});
  var $b = $('<div/>').css({'width': intended_editor_width+'ch', 'font-size': font_size_str, 'visibility': 'hidden', 'position': 'absolute', 'top': '0', 'left': '0'});
  $(document.body).append($a, $b);
  if(Math.abs($a.width() - $b.width()) > 1) {
    // Browsers such as IE (even IE11) that implement the ch unit badly.
    // Use "em" here instead of "px" because like "ch" it's relative to
    // the font size (likely unimportant), and like "ch" it rounds to
    // the nearest pixel so that elements are pixel-aligned (unimportant;
    // we could easily round here by hand).  Round up by a pixel or two
    // because that's sometimes needed.
    var new_width = ($a.width()/font_size + 0.1)+'em';
    console.log('working around poor implementation of "ch" unit: editor now '+new_width);
    $editor_and_testline.css('width', new_width);
    fix_needed = true;
  }
  $a.remove();
  $b.remove();
  return fix_needed;
}
var ch_is_broken = fix_ch_unit();
if(ch_is_broken) {
  $(window).on('resize', function() {
    fix_ch_unit();
  });
}

function wrappable_file_name_html(f) {
  // Dot is sometimes used as a separator but sometimes as an extension,
  // and it would look poor to wrap at short extensions,
  // so only wrap at '.' when there are enough characters after it.
  // Wrap after regular separators and before dots for aesthetic reasons.
  return _.escape(f).replace(/(?:[-_\/]|(?=\..{6}))/g, '$&<wbr>');
}

// A "set" here is an object with every key/value pair having
// the 'value' be 'true'. Underscore.js's set operations on arrays
// have poor asymptotic speed.
function to_set(enumerable) {
  var result = {};
  _.each(enumerable, function(member) {
    if(!_.isString(member) && !_.isNumber(member)) {
      throw("Bad type in conversion to set." +
               (_.isBoolean(member) ? " Is it already a set?" : ""));
    }
    result[member] = true;
  });
  return result;
}
function set_difference(minuend, subtrahend) {
  var result = {};
  _.each(minuend, function(member) {
    if(!subtrahend[member]) {
      result[member] = true;
    }
  });
  return result;
}
function set_sorted(set) {
  return _.sortBy(_.keys(set))
}
function set_size(set) {
  return _.size(set);
}

function display_editable_files() {
  var $editable_files = $('#editable_files');
  $editable_files.empty();
  _.each(set_sorted(state.editable_files), function(f) {
    var $a = $('<a/>').attr({
        'href': '#'+f,
        'data-filename': f
      }).html(wrappable_file_name_html(f));
    if(f === state.current_file) {
      $a.addClass('current-file');
    }
    $editable_files.append($a);
  });
}

function display_context_name() {
  var title = state.context_name;
  if(state.current_file != null) {
    title += '/' + state.current_file;
  }
  $('title').text(title);
  $('#context_name').html(wrappable_file_name_html(state.context_name));
}

// (display_editable_files() does this implicitly, so no need to
//  call this if you call that)
function display_which_file_is_current() {
  var $file_lines = $('#editable_files > a');
  $file_lines.removeClass('current-file');
  if(state.current_file != null) {
    ($file_lines.
      filter('[data-filename='+escape_for_css_selector_attr_value(state.current_file)+']').
      addClass('current-file'));
  }
}

function load_status() {
  $.ajax({
    url: '/status?'+cachebuster(),
    method: 'POST',
    headers: auth_headers(),
    success: function(data) {
      console.log(data);
      state.context_name = data.context_name;
      display_context_name();
      var all_old_files = state.editable_files;
      var all_new_files = to_set(data.editable_files);
      if(!_.isEqual(all_old_files, all_new_files)) {
        state.editable_files = all_new_files;
        display_editable_files();
      }
    }
  });
}

$('#editable_files').on('click', 'a', function(e) {
  e.preventDefault();
  e.stopPropagation();
  var f = $(this).attr('data-filename');
  console.log(f);
  load(f);
});

// Firefox has a text wrapping bug on very long lines sometimes
// (try an SVG)
// where it doesn't even realize that it's reporting a
// scrollHeight value that is lower than it should be.
// It wrapped some lines earlier/more than it usually does and
// forgot about that.  It forgot so thoroughly that I haven't
// yet found a way to check directly whether I need to trigger
// the reflow or not, so do it all the time (despite that it
// wastes a bit of time).
//
// Somehow, this code triggers a reflow that fixes it
// (tested on Firefox 40 on Linux).
function fix_reflow_bugs() {
  if(navigator.userAgent.indexOf('Gecko/') !== -1) {
    // say hi to the event loop before doing this,
    // so that it works (apparently)
    setTimeout(function(){
      // save and restore selection
      var selstart = editor.selectionStart;
      var selend = editor.selectionEnd;
      var seldir = editor.selectionDirection;
      // Make a type of change that will avoid Firefox's
      // optimizations where it detects whether anything
      // happened to the textarea, and does nothing if
      // it thinks nothing happened.
      var val = editor.value;
      editor.value = ' '+val;
      editor.value = val;
      // restore selection
      editor.setSelectionRange(selstart, selend, seldir);
    }, 0);
  }
}

function escape_for_css_selector_attr_value(str) {
  // see http://www.w3.org/TR/CSS21/syndata.html#strings
  return '"' + str.replace(/\\/g, '\\\\').replace(/"/g, '\\"') + '"';
}

function save_selection_location() {
  // TODO: also store for the null file by calling it ''
  // and not letting named files have the name ''.
  if(state.current_file != null) {
    state.remembered_selections[state.current_file] = {
      selectionStart: editor.selectionStart,
      selectionEnd: editor.selectionEnd,
      selectionDirection: editor.selectionDirection
    };
  }
}
function restore_selection_location() {
  if(state.remembered_selections[state.current_file]) {
    editor.setSelectionRange(
      state.remembered_selections[state.current_file].selectionStart,
      state.remembered_selections[state.current_file].selectionEnd,
      state.remembered_selections[state.current_file].selectionDirection
    );
  } else {
    editor.setSelectionRange(0, 0);
  }
}

function load(f) {
  if(f !== state.current_file) {
    if(trying_to_save) {
      try_save();
      // try again in 300ms, otherwise let the user click again...
      setTimeout(function() {
        if(!trying_to_save) {
          load(f);
        }
      }, 300);
    } else {
      $.ajax({
         url: '/get_file_contents?'+cachebuster(),
         method: 'POST',
         headers: _.assign(
           ((f != null) ? { 'X-File': f } : {}),
           auth_headers()),
         success: function(data) {
           save_selection_location();
           $(editor).blur();
           state.current_file = f;
           latest_time_that_the_server_has_all_our_data = last_sync_success = Date.now();

           editor.value = data;
           adjust_editor_height();
           restore_selection_location();
           fix_reflow_bugs();

           $(editor).focus();
           display_which_file_is_current();
           load_status();
         }
      });
    }
  }
}

function get_token() {
  var token_field = document.getElementById('token');
  var done = false;
  function got_input(recur) {
    if(done){return;}
    state.auth_token = token_field.value;
    test_auth(function() {
        if(done){return;}
        done = true;
        token_field.removeEventListener('input', got_input);
        token_field.value = '';
        $('#ask-for-token').remove();
        load_status();
        load();
      },
      // try again a short while later, because sometimes
      // the 'input' event arrives before the text does,
      // apparently (at least in Firefox 40 on Linux,
      // pasting into the text field).
      (recur ? undefined : function() {
        setTimeout(function() {
          got_input(true);
        }, 100);
    }));
  }
  got_input(); // in case no token is required (todo, serve different html in that case instead?)
  token_field.addEventListener('input', got_input);
  $('#ask-for-token').show();
}

function reload_while_keeping_state(force_reload_html_from_server) {
  save_selection_location();
  state.textarea_value = editor.value;
  sessionStorage.setItem('hilarious_editor_state', JSON.stringify(state));
  location.reload(force_reload_html_from_server);
}
window.reload_while_keeping_state = reload_while_keeping_state;
// Run right now, before DOMReady so that Dragon NaturallySpeaking will
// be able to notice any links that we render now.
(function(){
var stateJSON;
if(stateJSON = sessionStorage.getItem('hilarious_editor_state')) {
  sessionStorage.removeItem('hilarious_editor_state');
  state = JSON.parse(stateJSON);
  editor.value = state.textarea_value;
  delete state.textarea_value;
  adjust_editor_height();
  restore_selection_location();
  fix_reflow_bugs();
  display_context_name();
  display_editable_files();
  $('#ask-for-token').remove();
  $(editor).focus();
} else {
  get_token();
}
}());
$('#notes').click(function(){
  reload_while_keeping_state(true);
});

}());
</script>
</body>
</html>
