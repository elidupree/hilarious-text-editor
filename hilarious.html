<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Hi</title>
  <style>
/* CSS reset */
html,body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,select,p,blockquote,th,td{margin:0;padding:0}
h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:inherit;}
img{color:transparent;font-size:0;border:0;vertical-align:middle;}

html,body {
  height: 100%;
  width: 100%;
  color: #006;
  background-color: #fec;
  font-family: monospace;
  font-size: 10px;
  line-height: 10px;
}

#bar {
  float: left;
  min-height: 100%;
  width: 20em;
  background-color: #cfe;
}
#bar > div {
  margin: 1em 0;
}
#linenos {
  float: left;
  min-height: 100%;
  background-color: #fce;
  text-align: right;
  padding: 0 1px;
}
#linenos > a {
  display: block;
  text-decoration: none;
  color: #00f;
}
#linenos > a:visited {
  color: #00f;
}
#editor {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  float: left;
  resize: none;
  border-width: 0px;
  width: 80ch;
}
  </style>
</head>
<body>
  <div id="bar"><div id="save-status"></div><div>Known bugs: other users on the same computer can edit your stuff; You are not protected from editing your stuff twice; The editor doesn't notice if the file disappears and it keeps overwriting it; The line numbers are wrong if any of the lines are soft-wrapped; The line numbers are links but don't do anything.</div></div>
  <div id="linenos"></div>
  <textarea id="editor" autofocus></textarea>
<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script>
(function(){
"use strict";

var editor = document.getElementById('editor');
var save_status = document.getElementById('save-status');

function cachebuster() {
  return '' + Date.now() + Math.random();
}

// todo save if somdhc
var trying_to_save = false;
var save_interval = null;
var save_req = null;
var last_sync_attempt;
var last_edit = 0;
var last_sync_success;
var latest_time_that_the_server_has_all_our_data; // in theory updated continously when the server has our data, but actually only retroactively updated once the user types something to be the moment before they typed
function call_intermittently_while_trying_to_save() {
//function call_intermittently_when_active() {
//function call_intermittently() {
  var time_unsaved = Date.now() - latest_time_that_the_server_has_all_our_data;
  if(time_unsaved > 91000) {
    $(save_status).text('Last saved '+Math.round(time_unsaved/1000/60)+' minutes ago');
  }
  debounced_save();
}
function describe_since(time) {
  var duration = Date.now() - time;
  var date = new Date(time);
  var short_since = "since "+date.getHours()+":"+date.getMinutes()+":"+date.getSeconds();
  if(duration < 6000) {
    return "from the last few seconds";
  } else if(duration < 1.6*60*1000) {
    return short_since + " (" + Math.round(duration/1000) + " seconds ago)";
  } else if(duration < 1.6*3600*1000) {
    return short_since + " (" + Math.round(duration/1000/60) + " minutes ago)";
  } else if(duration < 1.6*86400*1000) {
    return "since " + date + " (" + Math.round(duration/1000/3600) + " hours ago)";
  } else {
    return "since " + date + " (" + Math.round(duration/1000/86400) + " days ago)";
  }
}

// this should be active the millisecond after someone starts typing.
// not 2.5 seconds later when the save attempt starts.
// why bother removing and adding it all the time.
function unsaved_beforeunload(e) {
  // In the time the user is looking at the message, maybe we can
  // squeeze in a save.  An example circumstance where this is useful:
  // if they click "don't close the tab" and then try closing the tab again,
  // hopefully the second time they close the tab it will already be saved
  // so we don't have to warn them again.
  try_save();
  var time_unsaved = Date.now() - latest_time_that_the_server_has_all_our_data;
  // some changes haven't saved yet!
  //var message = "changes from the last " + describe_millisecond_duration(time_unsaved) + " haven't saved yet!"
  var message = "changes " + describe_since(latest_time_that_the_server_has_all_our_data) + " haven't saved yet!"
  e.returnValue = message; // some browsers
  return message; // other browsers
}

function we_will_need_to_save() {
  if(!trying_to_save) {
    trying_to_save = true;
    window.addEventListener('beforeunload', unsaved_beforeunload);
  }
}
function starting_saving() {
  if(!save_interval) {
    save_interval = setInterval(call_intermittently_while_trying_to_save, 60000);
  }
  we_will_need_to_save();
}
function all_done_saving() {
  trying_to_save = false;
  if(save_interval !== null) {
    clearInterval(save_interval);
  }
  window.removeEventListener('beforeunload', unsaved_beforeunload);
  save_req = null;
  $(save_status).empty();
}
// always call debounced_save() instead of this
// to make sure we don't try to start saving while the user's
// typing
function try_save() {
  // is 30 seconds enough for saving??
  var req_timeout = 30000;
  var req = new XMLHttpRequest();
  if(save_req !== null) {
    if(last_sync_attempt + req_timeout < Date.now()) {
      save_req.abort();
    } else {
      return;
    }
  }
  save_req = req;
  last_sync_attempt = Date.now();
  starting_saving();
  function ack() {
    if(req.readyState === 4) { // complete
      if(req.status === 200 || req.status === 204) {
        latest_time_that_the_server_has_all_our_data = last_sync_success = last_sync_attempt;
        save_req = null;
        if(last_sync_success < last_edit) {
          debounced_save();
        } else {
          all_done_saving();
        }
      }
    }
  }
  req.onreadystatechange = ack;
  req.open('POST', '/save?'+cachebuster(), true)
  req.timeout = req_timeout;
  req.setRequestHeader('X-Please-Believe-I-Am-Not-Cross-Domain', 'yes');
  req.setRequestHeader('Content-Type', 'text/plain; charset=utf-8');
  req.send(editor.value);
}
var debounced_save = _.debounce(try_save, 2500);

//function editorchange_less_urgent() {
//  last_edit = Date.now();
//  try_save();
//}
//var debounced_editorchange_less_urgent = _.debounce(editorchange_less_urgent, 2500);

function adjust_editor_height() {
  if(editor.scrollHeight > editor.clientHeight) {
    editor.style.height = editor.scrollHeight+'px';
  }
}
function editor_input() {
  adjust_editor_height();
  var now = Date.now();
  if(last_edit <= latest_time_that_the_server_has_all_our_data) {
    if(latest_time_that_the_server_has_all_our_data < now) {
      latest_time_that_the_server_has_all_our_data = now - 1;
    }
  }
  last_edit = now;
  we_will_need_to_save();
  debounced_save();
  //debounced_editorchange_less_urgent();
}

for(var i = 1; i < 1000; ++i) {
  var str = ''+i;
  var text = document.createTextNode(str);
  var a = document.createElement('a');
  a.setAttribute('href', '#'+str);
  a.appendChild(text);
  linenos.appendChild(a);
}

editor.addEventListener('input', editor_input);

function load() {
  var req = new XMLHttpRequest();
  function got_contents() {
    if(req.readyState === 4) { // complete
      if(req.status === 200) {
        editor.value = req.responseText;
        latest_time_that_the_server_has_all_our_data = last_sync_success = Date.now();
        adjust_editor_height();
      }
    }
  }
  req.onreadystatechange = got_contents;
  req.open('POST', '/get_file_contents?'+cachebuster(), true)
  req.setRequestHeader('X-Please-Believe-I-Am-Not-Cross-Domain', 'yes');
  req.send(null);
}

load();

}());
</script>
</body>
</html>
